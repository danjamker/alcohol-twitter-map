{"ts":1378148672735,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1378148674603,"patch":[[{"diffs":[[1,"// Load data tiles from an AJAX data source\nL.TileLayer.Ajax = L.TileLayer.extend({\n    _requests: [],\n    _addTile: function (tilePoint) {\n        var tile = { datum: null, processed: false };\n        this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;\n        this._loadTile(tile, tilePoint);\n    },\n    // XMLHttpRequest handler; closure over the XHR object, the layer, and the tile\n    _xhrHandler: function (req, layer, tile, tilePoint) {\n        return function () {\n            if (req.readyState !== 4) {\n                return;\n            }\n            var s = req.status;\n            if ((s >= 200 && s < 300) || s === 304) {\n                tile.datum = JSON.parse(req.responseText);\n                layer._tileLoaded(tile, tilePoint);\n            } else {\n                layer._tileLoaded(tile, tilePoint);\n            }\n        };\n    },\n    // Load the requested tile via AJAX\n    _loadTile: function (tile, tilePoint) {\n        this._adjustTilePoint(tilePoint);\n        var layer = this;\n        var req = new XMLHttpRequest();\n        this._requests.push(req);\n        req.onreadystatechange = this._xhrHandler(req, layer, tile, tilePoint);\n        req.open('GET', this.getTileUrl(tilePoint), true);\n        req.send();\n    },\n    _reset: function () {\n        L.TileLayer.prototype._reset.apply(this, arguments);\n        for (var i in this._requests) {\n            this._requests[i].abort();\n        }\n        this._requests = [];\n    },\n    _update: function () {\n        if (this._map._panTransition && this._map._panTransition._inProgress) { return; }\n        if (this._tilesToLoad < 0) { this._tilesToLoad = 0; }\n        L.TileLayer.prototype._update.apply(this, arguments);\n    }\n});\n\n\nL.TileLayer.GeoJSON = L.TileLayer.Ajax.extend({\n    // Store each GeometryCollection's layer by key, if options.unique function is present\n    _keyLayers: {},\n\n    // Used to calculate svg path string for clip path elements\n    _clipPathRectangles: {},\n\n    initialize: function (url, options, geojsonOptions) {\n        L.TileLayer.Ajax.prototype.initialize.call(this, url, options);\n        this.geojsonLayer = new L.GeoJSON(null, geojsonOptions);\n    },\n    onAdd: function (map) {\n        this._map = map;\n        L.TileLayer.Ajax.prototype.onAdd.call(this, map);\n        map.addLayer(this.geojsonLayer);\n    },\n    onRemove: function (map) {\n        map.removeLayer(this.geojsonLayer);\n        L.TileLayer.Ajax.prototype.onRemove.call(this, map);\n    },\n    _reset: function () {\n        this.geojsonLayer.clearLayers();\n        this._keyLayers = {};\n        this._removeOldClipPaths();\n        L.TileLayer.Ajax.prototype._reset.apply(this, arguments);\n    },\n\n    // Remove clip path elements from other earlier zoom levels\n    _removeOldClipPaths: function  () {\n        for (var clipPathId in this._clipPathRectangles) {\n            var clipPathZXY = clipPathId.split('_').slice(1);\n            var zoom = parseInt(clipPathZXY[0], 10);\n            if (zoom !== this._map.getZoom()) {\n                var rectangle = this._clipPathRectangles[clipPathId];\n                this._map.removeLayer(rectangle);\n                var clipPath = document.getElementById(clipPathId);\n                if (clipPath !== null) {\n                    clipPath.parentNode.removeChild(clipPath);\n                }\n                delete this._clipPathRectangles[clipPathId];\n            }\n        }\n    },\n\n    // Recurse LayerGroups and call func() on L.Path layer instances\n    _recurseLayerUntilPath: function (func, layer) {\n        if (layer instanceof L.Path) {\n            func(layer);\n        }\n        else if (layer instanceof L.LayerGroup) {\n            // Recurse each child layer\n            layer.getLayers().forEach(this._recurseLayerUntilPath.bind(this, func), this);\n        }\n    },\n\n    _clipLayerToTileBoundary: function (layer, tilePoint) {\n        // Only perform SVG clipping if the browser is using SVG\n        if (!L.Path.SVG) { return; }\n\n        var svg = this._map._pathRoot;\n\n        // create the defs container if it doesn't exist\n        var defs = null;\n        if (svg.getElementsByTagName('defs').length === 0) {\n            defs = document.createElementNS(L.Path.SVG_NS, 'defs');\n            svg.insertBefore(defs, svg.firstChild);\n        }\n        else {\n            defs = svg.getElementsByTagName('defs')[0];\n        }\n\n        // Create the clipPath for the tile if it doesn't exist\n        var clipPathId = 'tileClipPath_' + tilePoint.z + '_' + tilePoint.x + '_' + tilePoint.y;\n        var clipPath = document.getElementById(clipPathId);\n        if (clipPath === null) {\n            clipPath = document.createElementNS(L.Path.SVG_NS, 'clipPath');\n            clipPath.id = clipPathId;\n\n            // Create a hidden L.Rectangle to represent the tile's area\n            var tileSize = this.options.tileSize,\n            nwPoint = tilePoint.multiplyBy(tileSize),\n            sePoint = nwPoint.add([tileSize, tileSize]),\n            nw = this._map.unproject(nwPoint),\n            se = this._map.unproject(sePoint);\n            this._clipPathRectangles[clipPathId] = new L.Rectangle(new L.LatLngBounds([nw, se]), {\n                opacity: 0,\n                fillOpacity: 0,\n                clickable: false,\n                noClip: true\n            });\n            this._map.addLayer(this._clipPathRectangles[clipPathId]);\n\n            // Add a clip path element to the SVG defs element\n            // With a path element that has the hidden rectangle's SVG path string  \n            var path = document.createElementNS(L.Path.SVG_NS, 'path');\n            var pathString = this._clipPathRectangles[clipPathId].getPathString();\n            path.setAttribute('d', pathString);\n            clipPath.appendChild(path);\n            defs.appendChild(clipPath);\n        }\n\n        // Add the clip-path attribute to reference the id of the tile clipPath\n        this._recurseLayerUntilPath(function (pathLayer) {\n            pathLayer._container.setAttribute('clip-path', 'url(#' + clipPathId + ')');\n        }, layer);\n    },\n\n    // Add a geojson object from a tile to the GeoJSON layer\n    // * If the options.unique function is specified, merge geometries into GeometryCollections\n    // grouped by the key returned by options.unique(feature) for each GeoJSON feature\n    // * If options.clipTiles is set, and the browser is using SVG, perform SVG clipping on each\n    // tile's GeometryCollection \n    addTileData: function (geojson, tilePoint) {\n        var features = L.Util.isArray(geojson) ? geojson : geojson.features,\n            i, len, feature;\n\n        if (features) {\n            for (i = 0, len = features.length; i < len; i++) {\n                // Only add this if geometry or geometries are set and not null\n                feature = features[i];\n                if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\n                    this.addTileData(features[i], tilePoint);\n                }\n            }\n            return this;\n        }\n\n        var options = this.geojsonLayer.options;\n\n        if (options.filter && !options.filter(geojson)) { return; }\n\n        var parentLayer = this.geojsonLayer;\n        var incomingLayer = null;\n        if (this.options.unique && typeof(this.options.unique) === 'function') {\n            var key = this.options.unique(geojson);\n\n            // When creating the layer for a unique key,\n            // Force the geojson to be a geometry collection\n            if (!(key in this._keyLayers && geojson.geometry.type !== 'GeometryCollection')) {\n                geojson.geometry = {\n                    type: 'GeometryCollection',\n                    geometries: [geojson.geometry]\n                };\n            }\n\n            // Transform the geojson into a new Layer\n            try {\n                incomingLayer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng);\n            }\n            // Ignore GeoJSON objects that could not be parsed\n            catch (e) {\n                return this;\n            }\n\n            // Add the incoming Layer to existing key's GeometryCollection\n            if (key in this._keyLayers) {\n                parentLayer = this._keyLayers[key];\n                parentLayer.feature.geometry.geometries.push(geojson.geometry);\n            }\n            // Convert the incoming GeoJSON feature into a new GeometryCollection layer\n            else {\n                incomingLayer.feature = L.GeoJSON.asFeature(geojson);\n                this._keyLayers[key] = incomingLayer;\n            }\n        }\n        // Add the incoming geojson feature to the L.GeoJSON Layer\n        else {\n            // Transform the geojson into a new layer\n            try {\n                incomingLayer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng);\n            }\n            // Ignore GeoJSON objects that could not be parsed\n            catch (e) {\n                return this;\n            }\n            incomingLayer.feature = L.GeoJSON.asFeature(geojson);\n        }\n        incomingLayer.defaultOptions = incomingLayer.options;\n\n        this.geojsonLayer.resetStyle(incomingLayer);\n\n        if (options.onEachFeature) {\n            options.onEachFeature(geojson, incomingLayer);\n        }\n        parentLayer.addLayer(incomingLayer);\n\n        // If options.clipTiles is set and the browser is using SVG\n        // then clip the layer using SVG clipping\n        if (this.options.clipTiles) {\n            this._clipLayerToTileBoundary(incomingLayer, tilePoint);\n        }\n        return this;\n    },\n\n    _tileLoaded: function (tile, tilePoint) {\n        L.TileLayer.Ajax.prototype._tileLoaded.apply(this, arguments);\n        if (tile.datum === null) { return null; }\n        this.addTileData(tile.datum, tilePoint);\n    }\n});\n"]],"start1":0,"start2":0,"length1":0,"length2":9841}]],"length":9841,"saved":false}
